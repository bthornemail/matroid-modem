# RFC-0011

# Closure Execution Virtual Machine (CEVM) v1.0

## Deterministic Semantic Closure Runtime

Status: Draft
Depends on: RFC-0002â€“0009

---

# 1. Purpose

Defines the runtime model for executing closures declared in the Closure Registry.

CEVM ensures:

* Determinism
* No arbitrary code execution
* Replay equivalence
* Sandboxed evaluation

Closures are declarative procedures evaluated by CEVM.

---

# 2. Execution Model

CEVM is:

* Pure functional
* Deterministic
* Stateless (v1.0)
* Event-driven

---

# 3. Closure Execution Flow

Input:

```id="ce1"
synset_call
```

Steps:

1. Lookup closure in registry
2. Validate face match
3. Evaluate rule graph
4. Produce result_coord
5. Emit synset_reply

---

# 4. Closure DSL

Closures use a minimal declarative DSL.

Example:

```json id="ce2"
{
  "closure_id": "closure:legislate.prohibition@v1",
  "vm_program": {
    "steps": [
      {"op":"assert_face","value":"predicate"},
      {"op":"require_synset","value":"prohibit.v.01"},
      {"op":"set_coord","x":0.8,"y":0.6,"z":0.5},
      {"op":"inherit_w"},
      {"op":"emit_reply"}
    ]
  }
}
```

---

# 5. VM Instruction Set

| Op             | Description          |
| -------------- | -------------------- |
| assert_face    | Fail if mismatch     |
| require_synset | Fail if absent       |
| set_coord      | Set x,y,z            |
| inherit_w      | Copy shard           |
| compute_drift  | Invoke RFC-0008      |
| emit_reply     | Produce synset_reply |

---

# 6. Determinism Constraints

CEVM MUST:

* Disallow random
* Disallow time-based logic
* Disallow network fetch
* Round floats to 6 decimals

---

# 7. Execution Output

```json id="ce3"
{
  "type": "synset_reply",
  "result_coord": {...},
  "faces_passed": 3,
  "drift": 0.08
}
```

---

# 8. Execution Invariant

> Given identical registry + input record, CEVM MUST produce identical output bit-for-bit.

---

# 9. Safety

CEVM is NOT:

* A JS runtime
* A scripting engine
* Turing complete

It is a constrained rule evaluator.

---

# 10. Future Extensions

v2.0 may allow:

* State accumulation
* Closure chaining
* Matroid-aware branching
