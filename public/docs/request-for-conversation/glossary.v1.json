{
  "schema": "semantic-basis-glossary",
  "version": "1.0.0",
  "status": "draft",
  "scope": "RFC-0001..RFC-0037",
  "generated_at": "2026-02-24",
  "categories": [
    "core",
    "semantics",
    "protocol",
    "projection",
    "governance",
    "identity",
    "proofs",
    "time",
    "federation",
    "bundling",
    "economics",
    "meta"
  ],
  "symbols": [
    {
      "symbol": "Œî",
      "name": "Amendment delta",
      "meaning": "A proposed change set applied to constitutional/policy parameters under meta-governance."
    },
    {
      "symbol": "ùìú",
      "name": "Matroid selector",
      "meaning": "Deterministic selector that returns a maximal independent subset of events given independence constraints."
    },
    {
      "symbol": "M¬≤",
      "name": "Modem squared",
      "meaning": "Round-trip closure operator: encode‚Üítransmit‚Üídecode plus replay equivalence normalization."
    },
    {
      "symbol": "D",
      "name": "Drift function",
      "meaning": "Composite semantic distance used for closure selection, admission thresholds, and federation gating."
    },
    {
      "symbol": "W",
      "name": "World",
      "meaning": "A replayable semantic system defined by basis, constitution/policy, and ledger prefix."
    },
    {
      "symbol": "T",
      "name": "Transcendent closure",
      "meaning": "Limit construction over worlds as basis dimensionality expands while preserving replayability."
    }
  ],
  "terms": [
    {
      "term": "Basis",
      "category": "core",
      "definition": "A finite, deterministic semantic coordinate system and canonical corpus used to resolve closures and validate events.",
      "aliases": ["Semantic Basis"],
      "rfc_refs": ["RFC-0001", "RFC-0016"],
      "invariants": [
        "basisHash MUST be computable deterministically from canonicalized canon inputs.",
        "All admitted events MUST match the active basisHash (or be quarantined)."
      ]
    },
    {
      "term": "basisHash",
      "category": "core",
      "definition": "A SHA-256 hash identifying a specific Basis (canon + normalization rules). Acts as the carrier agreement gate.",
      "aliases": ["basis_ref_hash"],
      "rfc_refs": ["RFC-0001", "RFC-0016"],
      "invariants": [
        "basisHash MUST be stable across platforms given identical inputs.",
        "basisHash mismatch MUST trigger quarantine (not silent acceptance)."
      ]
    },
    {
      "term": "World",
      "category": "core",
      "definition": "A replayable semantic system defined by basisHash, constitutionHash (and policy set), and a ledger prefix from which canonical state is derived.",
      "aliases": ["semantic world"],
      "rfc_refs": ["RFC-0001", "RFC-0022", "RFC-0032"],
      "invariants": [
        "A world MUST be reconstructible via deterministic replay.",
        "World identity MUST be hash-derivable from canonical components."
      ]
    },
    {
      "term": "worldHash",
      "category": "core",
      "definition": "A stable identifier for a World derived from basisHash, constitution/policy hashes, and canonical ledger-derived hashes (e.g., independent set hash).",
      "aliases": [],
      "rfc_refs": ["RFC-0022", "RFC-0032"],
      "invariants": [
        "worldHash MUST change if basis, constitution/policy, or canonical ledger-derived state changes.",
        "worldHash MUST be reproducible from the same inputs."
      ]
    },
    {
      "term": "Constitution",
      "category": "governance",
      "definition": "The meta-governance layer defining immutable invariants and amendment rules that constrain policy and world evolution.",
      "aliases": ["Semantic Constitution", "meta-governance"],
      "rfc_refs": ["RFC-0026", "RFC-0023"],
      "invariants": [
        "Constitutional invariants MUST NOT be violated without forking the world.",
        "Amendments MUST be expressed as deterministic deltas and converge by structural agreement."
      ]
    },
    {
      "term": "Policy",
      "category": "governance",
      "definition": "Declarative constraints evaluated over candidate events during matroid admission; policies enforce acceptance/quarantine/rejection without centralized moderation.",
      "aliases": ["PolicySet"],
      "rfc_refs": ["RFC-0023", "RFC-0026"],
      "invariants": [
        "Policy evaluation MUST be deterministic.",
        "Policy MUST NOT override constitutional invariants."
      ]
    },
    {
      "term": "Canon",
      "category": "core",
      "definition": "The authoritative, replay-derived semantic state computed from the ledger prefix under the active basis and constitution/policy.",
      "aliases": ["canonical state"],
      "rfc_refs": ["RFC-0016", "RFC-0007", "RFC-0032"],
      "invariants": [
        "Canon MUST be reproducible from the same event prefix (replay determinism).",
        "Canon MUST not depend on wall-clock time or nondeterministic sources."
      ]
    },
    {
      "term": "Narrative",
      "category": "meta",
      "definition": "Interpretive, human-readable layer that compiles deterministically into civic triples; it may contextualize canon but must not mutate canonical truth.",
      "aliases": ["myth layer", "story layer"],
      "rfc_refs": ["RFC-0033", "RFC-0028", "RFC-0012"],
      "invariants": [
        "Narrative compilation MUST be deterministic.",
        "Narrative contradictions to canon MUST surface as circuits or quarantine events."
      ]
    },
    {
      "term": "NDJSON",
      "category": "protocol",
      "definition": "Newline-Delimited JSON where each line is an atomic transaction/event boundary; used end-to-end for ingestion, ledger, and transport.",
      "aliases": ["jsonl", "jsonlines"],
      "rfc_refs": ["RFC-0001", "RFC-0007"],
      "invariants": [
        "Newline MUST be treated as the atomic commit boundary.",
        "Events MUST be processed in canonical order for replay."
      ]
    },
    {
      "term": "Ledger",
      "category": "protocol",
      "definition": "An ordered NDJSON event stream representing the history of a world. Canonical state is derived from a prefix of the ledger via deterministic replay.",
      "aliases": ["event log", "commit log"],
      "rfc_refs": ["RFC-0007", "RFC-0019"],
      "invariants": [
        "Ledger replay MUST be deterministic.",
        "Canonical ordering MUST be stable (e.g., (lc, self_hash))."
      ]
    },
    {
      "term": "Logical Time (lc)",
      "category": "time",
      "definition": "Monotonic logical counter for canonical ordering; governs replay. Wall clock time is UI-only.",
      "aliases": ["lc"],
      "rfc_refs": ["RFC-0021", "RFC-0007"],
      "invariants": [
        "Replay MUST order by logical time and stable tie-breakers.",
        "Wall clock timestamps MUST NOT influence determinism."
      ]
    },
    {
      "term": "Wall Clock Time (t)",
      "category": "time",
      "definition": "Unix epoch timestamp used only for UI/telemetry; excluded from deterministic ordering and hashing where required.",
      "aliases": ["timestamp"],
      "rfc_refs": ["RFC-0021", "RFC-0007"],
      "invariants": [
        "t MUST NOT affect replay equivalence.",
        "t MAY be present for observability only."
      ]
    },
    {
      "term": "SynsetRPC",
      "category": "protocol",
      "definition": "Process-centric RPC model resolving calls in semantic coordinate space and returning proof-carrying results (synset_reply) with drift metrics.",
      "aliases": ["Synset RPC"],
      "rfc_refs": ["RFC-0001", "RFC-0002", "RFC-0018"],
      "invariants": [
        "Resolution MUST be deterministic given basis + registry + inputs.",
        "Replies SHOULD include drift and proofs for federation."
      ]
    },
    {
      "term": "Closure",
      "category": "semantics",
      "definition": "A deterministic executable semantic procedure declared in the closure registry and evaluated by CEVM; identified by closure_id, face, synsets, and program.",
      "aliases": ["semantic closure"],
      "rfc_refs": ["RFC-0002", "RFC-0011"],
      "invariants": [
        "Closure execution MUST be deterministic.",
        "Closure MUST declare face/type constraints."
      ]
    },
    {
      "term": "Closure Registry",
      "category": "semantics",
      "definition": "A hashable catalog of closures with deterministic metadata and CEVM programs used for local resolution and replay.",
      "aliases": ["closure_registry.json"],
      "rfc_refs": ["RFC-0002", "RFC-0016"],
      "invariants": [
        "Registry MUST be canonically hashable and versioned.",
        "Resolution MUST include registry_hash to support proofs and federation."
      ]
    },
    {
      "term": "CEVM",
      "category": "semantics",
      "definition": "Closure Execution Virtual Machine: a constrained, non-Turing-complete deterministic evaluator for closure programs.",
      "aliases": ["Closure VM"],
      "rfc_refs": ["RFC-0011"],
      "invariants": [
        "No randomness, time-based logic, or network fetch permitted.",
        "Fixed numeric rounding required for stable drift results."
      ]
    },
    {
      "term": "Semantic Type System",
      "category": "semantics",
      "definition": "Strong typing layer for entities, relations, collectives, witnesses, coordinates, and closures to prevent category errors during compilation and execution.",
      "aliases": ["types"],
      "rfc_refs": ["RFC-0014", "RFC-0017"],
      "invariants": [
        "Type inference MUST be deterministic.",
        "Type soundness: valid executions cannot produce values outside declared types."
      ]
    },
    {
      "term": "Type Inference",
      "category": "semantics",
      "definition": "Deterministic inference rules mapping tokens/structures to semantic types and validating CivicTriple well-formedness.",
      "aliases": ["typing rules"],
      "rfc_refs": ["RFC-0017", "RFC-0014"],
      "invariants": [
        "No backtracking in v1.0 (left-to-right deterministic inference).",
        "Inference failures MUST emit type_error records."
      ]
    },
    {
      "term": "Civic Compiler",
      "category": "governance",
      "definition": "Deterministic pipeline converting founding/legal texts into civic_triple records with synset anchors, character faces, and epistemic modes.",
      "aliases": ["constitutional compiler"],
      "rfc_refs": ["RFC-0003", "RFC-0012"],
      "invariants": [
        "Identical inputs MUST produce bit-identical civic triples after canonicalization.",
        "Modal/negation handling MUST be explicit and reproducible."
      ]
    },
    {
      "term": "CivicTriple",
      "category": "governance",
      "definition": "A typed SPO triple extracted from civic texts with synset anchors, character face routing, and epistemic mode classification.",
      "aliases": ["civic_triple"],
      "rfc_refs": ["RFC-0003", "RFC-0012", "RFC-0014"],
      "invariants": [
        "Must satisfy typing: subject=Entity, predicate=Relation, object=Collective (or subtypes).",
        "Must retain source provenance for reproducibility."
      ]
    },
    {
      "term": "Face",
      "category": "semantics",
      "definition": "One of the epistemic roles used for routing and validation: subject, predicate, object, centroid.",
      "aliases": ["epistemic face"],
      "rfc_refs": ["RFC-0009", "RFC-0014"],
      "invariants": [
        "Closure.face MUST match character mapping unless transformed by a defined rotation operator.",
        "Face algebra operations MUST be deterministic."
      ]
    },
    {
      "term": "Character Encoding",
      "category": "semantics",
      "definition": "Routing/type annotation mapping narrative archetypes to epistemic faces (Solon‚Üísubject, Solomon‚Üípredicate, Asabiyyah‚Üíobject, Metatron‚Üícentroid).",
      "aliases": ["characters", "role encoding"],
      "rfc_refs": ["RFC-0009", "RFC-0028", "RFC-0033"],
      "invariants": [
        "character and face fields MUST agree.",
        "Character encoding MUST not override typing; it refines routing."
      ]
    },
    {
      "term": "Quadrants (KK/KU/UK/UU)",
      "category": "projection",
      "definition": "Epistemic mode classification used for projection and carrier encoding: Known Known, Known Unknown, Unknown Known, Unknown Unknown.",
      "aliases": ["Rumsfeld quadrants"],
      "rfc_refs": ["RFC-0001", "RFC-0013", "RFC-0021"],
      "invariants": [
        "Quadrant mapping rules MUST be explicit and stable for replay.",
        "Quadrant colors/hues MUST be consistent for modem decode/encode."
      ]
    },
    {
      "term": "Drift",
      "category": "semantics",
      "definition": "Composite distance function measuring deviation between requested and resolved semantics across coordinate, synset, and intent components.",
      "aliases": ["D_total"],
      "rfc_refs": ["RFC-0008", "RFC-0010", "RFC-0018"],
      "invariants": [
        "Drift computation MUST be deterministic with fixed rounding.",
        "Admission thresholds MUST be policy/constitution constrained."
      ]
    },
    {
      "term": "Matroid Independence",
      "category": "semantics",
      "definition": "Independence predicate over event subsets ensuring coherence under basis agreement, drift thresholds, face quorum, and contradiction rules.",
      "aliases": ["independence"],
      "rfc_refs": ["RFC-0005", "RFC-0020"],
      "invariants": [
        "Selection MUST be deterministic under canonical event ordering.",
        "Independence rules MUST be treated as world-defining invariants (or fork on change)."
      ]
    },
    {
      "term": "Circuit",
      "category": "semantics",
      "definition": "A minimal dependent subset of events indicating a contradiction or violation of independence constraints; used for debugging and governance signals.",
      "aliases": ["minimal conflict"],
      "rfc_refs": ["RFC-0005", "RFC-0030"],
      "invariants": [
        "Circuits MUST be reportable and reproducible from the same inputs.",
        "Circuit detection MUST not introduce nondeterminism."
      ]
    },
    {
      "term": "SAB (16√ó16 projection)",
      "category": "projection",
      "definition": "Canonical 16√ó16 grid projection of semantic state; meta/UU layer occupies rows 12‚Äì15; columns discretize w.",
      "aliases": ["Shared Array Basis", "SAB grid"],
      "rfc_refs": ["RFC-0006", "RFC-0001"],
      "invariants": [
        "row/col mapping MUST be identical across implementations.",
        "Projection MUST be derivable from the independent set (not raw ledger noise)."
      ]
    },
    {
      "term": "w coefficient",
      "category": "projection",
      "definition": "Shard/depth coordinate in [0,1] used for routing and SAB column mapping (col=floor(w*16)).",
      "aliases": ["w shard", "depth"],
      "rfc_refs": ["RFC-0006", "RFC-0008"],
      "invariants": [
        "Column mapping MUST clamp to [0..15].",
        "w misalignment SHOULD be weighted more heavily in drift."
      ]
    },
    {
      "term": "Modem",
      "category": "protocol",
      "definition": "Carrier encode/decode transport operator mapping semantic symbols to physical or network channels (light/serial/webrtc) and back to NDJSON.",
      "aliases": ["carrier modem"],
      "rfc_refs": ["RFC-0013", "RFC-0001"],
      "invariants": [
        "Carrier encoding MUST be basis-agnostic; meaning is in NDJSON.",
        "Decode MUST be calibrated and reproducible under noise tolerances."
      ]
    },
    {
      "term": "Hardware Light Ring Carrier Encoding",
      "category": "protocol",
      "definition": "Standard mapping from quadrants and Fano line symbols to hue/brightness/phase schedules over a baud cycle for physical transmission.",
      "aliases": ["light carrier"],
      "rfc_refs": ["RFC-0013"],
      "invariants": [
        "FULL_CYCLE tick duration MUST be fixed for a given protocol version.",
        "Hue buckets and tolerances MUST be specified for demodulation."
      ]
    },
    {
      "term": "Web Serial Device Profile",
      "category": "protocol",
      "definition": "NDJSON-over-USB serial profile for sensor devices (ESP32 etc.) emitting probe records and optionally receiving render instructions.",
      "aliases": ["ESP32 profile"],
      "rfc_refs": ["RFC-0004"],
      "invariants": [
        "Devices MUST be semantic-blind; portal is semantic authority.",
        "One JSON per line; invalid lines ignored."
      ]
    },
    {
      "term": "Proof Certificate (closure_proof)",
      "category": "proofs",
      "definition": "Verifiable artifact that a closure resolution was computed deterministically and satisfies drift/quorum constraints; supports federation admission.",
      "aliases": ["closure_proof"],
      "rfc_refs": ["RFC-0015", "RFC-0018"],
      "invariants": [
        "Verifier MUST be able to recompute the proof offline.",
        "Proof validates determinism; signature validates authorship."
      ]
    },
    {
      "term": "Proof-Carrying Federation",
      "category": "federation",
      "definition": "Cross-basis exchange where events include signatures and closure proofs and are admitted only if drift and proofs verify locally.",
      "aliases": ["PCF"],
      "rfc_refs": ["RFC-0018", "RFC-0010"],
      "invariants": [
        "No implicit trust: drift and proof MUST be recomputed.",
        "Federation MUST not break local replay determinism."
      ]
    },
    {
      "term": "Semantic Consensus Without Blockchain",
      "category": "federation",
      "definition": "Convergence model where nodes independently derive identical independent-set hashes via deterministic selection and drift-gated admission (no voting/mining).",
      "aliases": ["structural consensus"],
      "rfc_refs": ["RFC-0020"],
      "invariants": [
        "Convergence condition: hash(I_A)==hash(I_B).",
        "Consensus MUST be quorum-free and emerge from identical rules + inputs."
      ]
    },
    {
      "term": "Bundle (.simplex)",
      "category": "bundling",
      "definition": "Deterministic replayable narrative/world container including canon inputs, registry snapshot, ledger, projection state, and assets.",
      "aliases": ["simplex bundle"],
      "rfc_refs": ["RFC-0019", "RFC-0016"],
      "invariants": [
        "Bundle hashes MUST verify before replay.",
        "Bundle load MUST reproduce identical SAB/canvas outputs."
      ]
    },
    {
      "term": "Resurrection",
      "category": "time",
      "definition": "Deterministic world reconstitution from canonical bundle + ledger prefix producing identical independent set, canvas, and world hashes.",
      "aliases": ["historical reconstruction"],
      "rfc_refs": ["RFC-0032"],
      "invariants": [
        "Any deviation in replay outputs indicates resurrection failure.",
        "Resurrection MUST be possible offline."
      ]
    },
    {
      "term": "Governance Memory (Mythopoetic Layer)",
      "category": "meta",
      "definition": "Narrative fragments linked to commits that preserve interpretive continuity and governance lessons without mutating canonical triples.",
      "aliases": ["myth memory"],
      "rfc_refs": ["RFC-0033", "RFC-0027"],
      "invariants": [
        "Narrative may influence interpretation but cannot override independence logic.",
        "Contradictions to canon must be flagged as myth circuits."
      ]
    },
    {
      "term": "Value Without Tokens",
      "category": "economics",
      "definition": "Non-monetary value function measuring structural contribution (proof strength, drift reduction, circuit resolution, convergence contribution).",
      "aliases": ["canonical economics"],
      "rfc_refs": ["RFC-0024"],
      "invariants": [
        "No balances, minting, or tradable tokens.",
        "Value must derive from measurable structural contribution."
      ]
    },
    {
      "term": "Semantic Identity",
      "category": "identity",
      "definition": "Stable identity object defined by cryptographic control and canonical type profile; may represent human, agent, or collective.",
      "aliases": ["identityHash"],
      "rfc_refs": ["RFC-0029", "RFC-0025"],
      "invariants": [
        "identityHash MUST be stable given public key + type profile.",
        "Identity changes require new identity (no silent mutation)."
      ]
    },
    {
      "term": "Epistemic Justice",
      "category": "identity",
      "definition": "Bias correction protocol based on equal evaluation under drift/proof/independence constraints; adjusts thresholds but does not override truth.",
      "aliases": ["bias correction"],
      "rfc_refs": ["RFC-0030"],
      "invariants": [
        "Justice cannot auto-accept; it can only adjust evaluation thresholds deterministically.",
        "Group definitions must be non-demographic and structurally defined."
      ]
    },
    {
      "term": "Treaty",
      "category": "federation",
      "definition": "Typed, signed boundary agreement defining allowable cross-world exchange scopes, drift caps, and validity constraints without collapsing sovereignty.",
      "aliases": ["inter-world treaty"],
      "rfc_refs": ["RFC-0031"],
      "invariants": [
        "Treaties must not alter internal constitutions; only define exchange boundaries.",
        "Treaty events must be logged and replayable."
      ]
    },
    {
      "term": "Ontological Death",
      "category": "meta",
      "definition": "Formal termination of a world when no valid independent extension exists under constitutional invariants and convergence remains below threshold for a sustained period.",
      "aliases": ["world dissolution"],
      "rfc_refs": ["RFC-0035"],
      "invariants": [
        "World dissolution freezes ledger and preserves replayability forever.",
        "No deletion; only archival, succession, or forks."
      ]
    },
    {
      "term": "Semantic Evolution",
      "category": "meta",
      "definition": "Controlled adaptation of drift thresholds, policies, or basis dimensions under constitutional constraints that improves stability metrics without breaking determinism.",
      "aliases": ["world evolution"],
      "rfc_refs": ["RFC-0036", "RFC-0026"],
      "invariants": [
        "Evolution must not reduce replay determinism or proof integrity.",
        "Evolution is bounded by invariants; disagreements fork worlds."
      ]
    },
    {
      "term": "Transcendent Closure",
      "category": "meta",
      "definition": "Meta-meta limit construction over expanding bases/worlds where worlds are nodes in a higher-order coherence structure and replayability remains preserved.",
      "aliases": ["meta-world"],
      "rfc_refs": ["RFC-0037", "RFC-0034"],
      "invariants": [
        "Meta-layer must remain replayable and cannot retroactively override world invariants.",
        "Identity and compatibility must remain structurally definable."
      ]
    }
  ]
}